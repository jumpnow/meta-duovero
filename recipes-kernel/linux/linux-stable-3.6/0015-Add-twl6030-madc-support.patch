From 35634fc599d1f0da380c47e4fc142ec17509a82a Mon Sep 17 00:00:00 2001
From: Scott Ellis <scott@jumpnowtek.com>
Date: Mon, 10 Nov 2014 15:30:35 -0500
Subject: [PATCH] Add twl6030 MADC support

Backported from an Android kernel.
---
 arch/arm/mach-omap2/board-duovero.c |  38 ++--
 arch/arm/mach-omap2/twl-common.c    |   7 +
 drivers/mfd/Kconfig                 |  14 +-
 drivers/mfd/Makefile                |   1 +
 drivers/mfd/twl-core.c              |  31 ++++
 drivers/mfd/twl6030-madc.c          | 356 ++++++++++++++++++++++++++++++++++++
 include/linux/i2c/twl6030-madc.h    |  86 +++++++++
 7 files changed, 520 insertions(+), 13 deletions(-)
 create mode 100644 drivers/mfd/twl6030-madc.c
 create mode 100644 include/linux/i2c/twl6030-madc.h

diff --git a/arch/arm/mach-omap2/board-duovero.c b/arch/arm/mach-omap2/board-duovero.c
index b8dd650..b9aebaa 100644
--- a/arch/arm/mach-omap2/board-duovero.c
+++ b/arch/arm/mach-omap2/board-duovero.c
@@ -230,18 +230,32 @@ static struct twl4030_platform_data duovero_twldata;
 
 static int __init duovero_i2c_init(void)
 {
-	omap4_pmic_get_config(&duovero_twldata, TWL_COMMON_PDATA_USB,
-			TWL_COMMON_REGULATOR_VDAC |
-			TWL_COMMON_REGULATOR_VAUX2 |
-			TWL_COMMON_REGULATOR_VAUX3 |
-			TWL_COMMON_REGULATOR_VMMC |
-			TWL_COMMON_REGULATOR_VPP |
-			TWL_COMMON_REGULATOR_VANA |
-			TWL_COMMON_REGULATOR_VCXIO |
-			TWL_COMMON_REGULATOR_VUSB |
-			TWL_COMMON_REGULATOR_CLK32KG |
-			TWL_COMMON_REGULATOR_V1V8 |
-			TWL_COMMON_REGULATOR_V2V1);
+	u32 pdata_flags = 0;
+
+	u32 regulator_flags = TWL_COMMON_REGULATOR_VAUX2 |
+		TWL_COMMON_REGULATOR_VAUX3 |
+		TWL_COMMON_REGULATOR_VMMC |
+		TWL_COMMON_REGULATOR_VPP |
+		TWL_COMMON_REGULATOR_VANA |
+		TWL_COMMON_REGULATOR_VCXIO |
+		TWL_COMMON_REGULATOR_VUSB |
+		TWL_COMMON_REGULATOR_CLK32KG |
+		TWL_COMMON_REGULATOR_V1V8 |
+		TWL_COMMON_REGULATOR_V2V1;
+
+#if defined(CONFIG_USB_MUSB_HDRC) || \
+		defined (CONFIG_USB_MUSB_HDRC_MODULE)
+	pdata_flags |= TWL_COMMON_PDATA_USB;
+#endif
+
+#if defined(CONFIG_TWL6030_MADC) || \
+		defined (CONFIG_TWL6030_MADC_MODULE)
+	pdata_flags |= TWL_COMMON_PDATA_MADC;
+#endif
+
+	omap4_pmic_get_config(&duovero_twldata, pdata_flags,
+			regulator_flags);
+ 
 	omap4_pmic_init("twl6030", &duovero_twldata,
 			&twl6040_data, OMAP44XX_IRQ_SYS_2N);
 	omap_register_i2c_bus(2, 400, NULL, 0);
diff --git a/arch/arm/mach-omap2/twl-common.c b/arch/arm/mach-omap2/twl-common.c
index d272034..cfcf33b 100644
--- a/arch/arm/mach-omap2/twl-common.c
+++ b/arch/arm/mach-omap2/twl-common.c
@@ -259,6 +259,10 @@ static struct twl4030_usb_data omap4_usb_pdata = {
 	.phy_suspend	= omap4430_phy_suspend,
 };
 
+static struct twl4030_madc_platform_data omap4_madc_pdata = {
+	.irq_line = 1,
+};
+
 static struct regulator_init_data omap4_vdac_idata = {
 	.constraints = {
 		.min_uV			= 1800000,
@@ -503,6 +507,9 @@ void __init omap4_pmic_get_config(struct twl4030_platform_data *pmic_data,
 	if (pdata_flags & TWL_COMMON_PDATA_USB && !pmic_data->usb)
 		pmic_data->usb = &omap4_usb_pdata;
 
+	if (pdata_flags & TWL_COMMON_PDATA_MADC && !pmic_data->madc)
+		pmic_data->madc = &omap4_madc_pdata;
+
 	/* Common regulator configurations */
 	if (regulators_flags & TWL_COMMON_REGULATOR_VDAC && !pmic_data->vdac)
 		pmic_data->vdac = &omap4_vdac_idata;
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index b1a1462..bb888e1 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -271,7 +271,7 @@ config TWL4030_CORE
 
 config TWL4030_MADC
 	tristate "Texas Instruments TWL4030 MADC"
-	depends on TWL4030_CORE
+	depends on TWL4030_CORE && !ARCH_OMAP4
 	help
 	This driver provides support for triton TWL4030-MADC. The
 	driver supports both RT and SW conversion methods.
@@ -308,6 +308,18 @@ config TWL6030_PWM
 	  Say yes here if you want support for TWL6030 PWM.
 	  This is used to control charging LED brightness.
 
+config TWL6030_MADC
+	tristate "Texas Instruments TWL6030 MADC"
+	depends on TWL4030_CORE && ARCH_OMAP4 && DEBUG_FS
+	help
+	  This driver provides support for TWL6030-MADC. The
+	  driver supports both RT and SW conversion methods.
+
+	  Read the ADC values from /sys/kernel/debug/twl6030_madc  
+
+	  This driver can be built as a module. If so it will be
+	  named twl6030-madc
+
 config TWL6040_CORE
 	bool "Support for TWL6040 audio codec"
 	depends on I2C=y && GENERIC_HARDIRQS
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index 79dd22d..2ee62e6 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -61,6 +61,7 @@ obj-$(CONFIG_MENELAUS)		+= menelaus.o
 
 obj-$(CONFIG_TWL4030_CORE)	+= twl-core.o twl4030-irq.o twl6030-irq.o
 obj-$(CONFIG_TWL4030_MADC)      += twl4030-madc.o
+obj-$(CONFIG_TWL6030_MADC)    += twl6030-madc.o
 obj-$(CONFIG_TWL4030_POWER)    += twl4030-power.o
 obj-$(CONFIG_MFD_TWL4030_AUDIO)	+= twl4030-audio.o
 obj-$(CONFIG_TWL6030_PWM)	+= twl6030-pwm.o
diff --git a/drivers/mfd/twl-core.c b/drivers/mfd/twl-core.c
index 1c32afe..7830624 100644
--- a/drivers/mfd/twl-core.c
+++ b/drivers/mfd/twl-core.c
@@ -45,6 +45,7 @@
 
 #include <linux/i2c.h>
 #include <linux/i2c/twl.h>
+#include <linux/i2c/twl4030-madc.h>
 
 #include "twl-core.h"
 
@@ -82,12 +83,25 @@
 #define twl_has_regulator()	false
 #endif
 
+#if defined(CONFIG_TWL6030_MADC) || defined(CONFIG_TWL6030_MADC_MODULE)
+#define twl6030_has_madc()	true
+#else
+#define twl6030_has_madc()	false
+#endif
+
 #if defined(CONFIG_TWL4030_MADC) || defined(CONFIG_TWL4030_MADC_MODULE)
 #define twl_has_madc()	true
 #else
 #define twl_has_madc()	false
 #endif
 
+#if defined(CONFIG_SENSORS_TWL4030_MADC) \
+	|| defined(CONFIG_SENSORS_TWL4030_MADC_MODULE)
+#define twl_has_madc_hwmon()	true
+#else
+#define twl_has_madc_hwmon()	false
+#endif
+
 #ifdef CONFIG_TWL4030_POWER
 #define twl_has_power()        true
 #else
@@ -685,6 +699,14 @@ add_children(struct twl4030_platform_data *pdata, unsigned irq_base,
 			return PTR_ERR(child);
 	}
 
+	if (twl6030_has_madc() && pdata->madc) {
+		child = add_child(2, "twl6030_madc",
+				pdata->madc, sizeof(*pdata->madc),
+				true, irq_base + MADC_INTR_OFFSET, 0);
+		if (IS_ERR(child))
+			return PTR_ERR(child);
+	}
+
 	if (twl_has_madc() && pdata->madc) {
 		child = add_child(2, "twl4030_madc",
 				pdata->madc, sizeof(*pdata->madc),
@@ -693,6 +715,15 @@ add_children(struct twl4030_platform_data *pdata, unsigned irq_base,
 			return PTR_ERR(child);
 	}
 
+	if (twl_has_madc_hwmon()) {
+		child = add_child(2, "twl4030_madc_hwmon",
+				NULL, 0,
+				true, irq_base + MADC_INTR_OFFSET, 0);
+
+		if (IS_ERR(child))
+			return PTR_ERR(child);
+	}
+
 	if (twl_has_rtc()) {
 		/*
 		 * REVISIT platform_data here currently might expose the
diff --git a/drivers/mfd/twl6030-madc.c b/drivers/mfd/twl6030-madc.c
new file mode 100644
index 0000000..90def92
--- /dev/null
+++ b/drivers/mfd/twl6030-madc.c
@@ -0,0 +1,356 @@
+/*
+ *
+ * TWL6030 MADC module driver-This driver only implements the ADC read
+ * functions
+ *
+ * Copyright (C) 2011 Samsung Telecommunications of America
+ *
+ * Based on twl4030-madc.c
+ * Copyright (C) 2008 Nokia Corporation
+ * Mikko Ylinen <mikko.k.ylinen@nokia.com>
+ *
+ * Amit Kucheria <amit.kucheria@canonical.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/i2c/twl.h>
+#include <linux/i2c/twl6030-madc.h>
+#include <linux/module.h>
+#include <linux/stddef.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/mutex.h>
+#include <linux/bitops.h>
+#include <linux/jiffies.h>
+#include <linux/types.h>
+#include <linux/gfp.h>
+#include <linux/err.h>
+// #include <linux/wakelock.h>
+
+#define GPADCS		(1 << 1)
+#define GPADCR		(1 << 0)
+#define REG_TOGGLE1	0x90
+
+#define DRIVER_NAME	(twl6030_madc_driver.driver.name)
+static struct platform_driver twl6030_madc_driver;
+
+/*
+ * struct twl6030_madc_data - a container for madc info
+ * @dev - pointer to device structure for madc
+ * @lock - mutex protecting this data structure
+ */
+struct twl6030_madc_data {
+	struct device *dev;
+	struct mutex lock;
+	struct dentry		*file;
+	//struct wake_lock wakelock;
+};
+
+static struct twl6030_madc_data *twl6030_madc;
+static u8 gpadc_ctrl_reg;
+
+static inline int twl6030_madc_start_conversion(struct twl6030_madc_data *madc)
+{
+	int ret;
+
+	ret = twl_i2c_write_u8(TWL6030_MODULE_ID1, GPADCS, REG_TOGGLE1);
+	if (ret) {
+		dev_err(madc->dev, "unable to write register 0x%X\n",
+			REG_TOGGLE1);
+		return ret;
+	}
+
+	udelay(100);
+	ret = twl_i2c_write_u8(TWL_MODULE_MADC, TWL6030_MADC_SP1,
+				TWL6030_MADC_CTRL_P1);
+	if (ret) {
+		dev_err(madc->dev, "unable to write register 0x%X\n",
+			TWL6030_MADC_CTRL_P1);
+		return ret;
+	}
+	return 0;
+}
+
+/*
+ * Function that waits for conversion to be ready
+ * @madc - pointer to twl4030_madc_data struct
+ * @timeout_ms - timeout value in milliseconds
+ * @status_reg - ctrl register
+ * returns 0 if succeeds else a negative error value
+ */
+static int twl6030_madc_wait_conversion_ready(struct twl6030_madc_data *madc,
+					      unsigned int timeout_ms,
+					      u8 status_reg)
+{
+	unsigned long timeout;
+	unsigned long delta;
+	u8 reg;
+	int ret;
+
+	delta = msecs_to_jiffies(timeout_ms);
+
+	if (delta < 2)
+		delta = 2;
+
+	//wake_lock(&madc->wakelock);
+	timeout = jiffies + delta;
+	do {
+		ret = twl_i2c_read_u8(TWL6030_MODULE_MADC, &reg, status_reg);
+		if (ret) {
+			dev_err(madc->dev,
+				"unable to read status register 0x%X\n",
+				status_reg);
+			goto unlock;
+		}
+		if (!(reg & TWL6030_MADC_BUSY) && (reg & TWL6030_MADC_EOCP1)) {
+			ret = 0;
+			goto unlock;
+		}
+
+		if (time_after(jiffies, timeout))
+			break;
+
+		usleep_range(500, 2000);
+	} while (1);
+
+	dev_err(madc->dev, "conversion timeout, ctrl_px=0x%08x\n", reg);
+	ret = -EAGAIN;
+
+unlock:
+	//wake_unlock(&madc->wakelock);
+	return ret;
+}
+
+/*
+ * Function to read a particular channel value.
+ * @madc - pointer to struct twl6030_madc_data
+ * @reg - lsb of ADC Channel
+ * If the i2c read fails it returns an error else returns 0.
+ */
+static int twl6030_madc_channel_raw_read(struct twl6030_madc_data *madc,
+					u8 reg)
+{
+	u8 msb, lsb;
+	int ret;
+
+	mutex_lock(&madc->lock);
+	ret = twl6030_madc_start_conversion(twl6030_madc);
+	if (ret)
+		goto unlock;
+
+	ret = twl6030_madc_wait_conversion_ready(twl6030_madc, 5,
+						TWL6030_MADC_CTRL_P1);
+	if (ret)
+		goto unlock;
+
+	/*
+	 * For each ADC channel, we have MSB and LSB register
+	 * pair. MSB address is always LSB address+1. reg parameter is
+	 * the address of LSB register
+	 */
+	ret = twl_i2c_read_u8(TWL6030_MODULE_MADC, &msb, reg + 1);
+	if (ret) {
+		dev_err(madc->dev, "unable to read MSB register 0x%X\n",
+			reg + 1);
+		goto unlock;
+	}
+	ret = twl_i2c_read_u8(TWL6030_MODULE_MADC, &lsb, reg);
+	if (ret) {
+		dev_err(madc->dev, "unable to read LSB register 0x%X\n", reg);
+		goto unlock;
+	}
+	ret = (int)((msb << 8) | lsb);
+unlock:
+	/* Disable GPADC for power savings. */
+	twl_i2c_write_u8(TWL6030_MODULE_ID1, GPADCR, REG_TOGGLE1);
+	mutex_unlock(&madc->lock);
+	return ret;
+}
+
+/*
+ * Return channel value
+ * Or < 0 on failure.
+ */
+int twl6030_get_madc_conversion(int channel_no)
+{
+	u8 reg = TWL6030_MADC_GPCH0_LSB + (2 * channel_no);
+	if (!twl6030_madc) {
+		pr_err("%s: No ADC device\n", __func__);
+		return -EINVAL;
+	}
+	if (channel_no >= TWL6030_MADC_MAX_CHANNELS) {
+		dev_err(twl6030_madc->dev,
+			"%s: Channel number (%d) exceeds max (%d)\n",
+			__func__, channel_no, TWL6030_MADC_MAX_CHANNELS);
+		return -EINVAL;
+	}
+
+	return twl6030_madc_channel_raw_read(twl6030_madc, reg);
+}
+EXPORT_SYMBOL_GPL(twl6030_get_madc_conversion);
+
+#ifdef CONFIG_DEBUG_FS
+
+static int debug_twl6030_madc_show(struct seq_file *s, void *_)
+{
+	int i, result;
+	for (i = 0; i < TWL6030_MADC_MAX_CHANNELS; i++) {
+		result = twl6030_get_madc_conversion(i);
+		seq_printf(s, "channel %3d returns result %d\n",
+			i, result);
+	}
+	return 0;
+}
+
+static int debug_twl6030_madc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, debug_twl6030_madc_show, inode->i_private);
+}
+
+static const struct file_operations debug_fops = {
+	.open		= debug_twl6030_madc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+#define DEBUG_FOPS	(&debug_fops)
+
+#else
+#define DEBUG_FOPS	NULL
+#endif
+
+/*
+ * Initialize MADC
+ */
+static int __devinit twl6030_madc_probe(struct platform_device *pdev)
+{
+	struct twl6030_madc_data *madc;
+	struct twl4030_madc_platform_data *pdata = pdev->dev.platform_data;
+
+	dev_err(&pdev->dev, "Inside twl6030_madc_probe\n");
+
+	if (!pdata) {
+		dev_err(&pdev->dev, "platform_data not available\n");
+		return -EINVAL;
+	}
+	madc = kzalloc(sizeof(*madc), GFP_KERNEL);
+	if (!madc)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, madc);
+	madc->dev = &pdev->dev;
+	mutex_init(&madc->lock);
+	madc->file = debugfs_create_file(DRIVER_NAME, S_IRUGO, NULL,
+					madc, DEBUG_FOPS);
+	//wake_lock_init(&madc->wakelock, WAKE_LOCK_SUSPEND, "twl6030 adc");
+	twl6030_madc = madc;
+	return 0;
+}
+
+static int __devexit twl6030_madc_remove(struct platform_device *pdev)
+{
+	struct twl6030_madc_data *madc = platform_get_drvdata(pdev);
+
+	//wake_lock_destroy(&madc->wakelock);
+	mutex_destroy(&madc->lock);
+	free_irq(platform_get_irq(pdev, 0), madc);
+	platform_set_drvdata(pdev, NULL);
+	twl6030_madc = NULL;
+	debugfs_remove(madc->file);
+	kfree(madc);
+
+	return 0;
+}
+
+static int twl6030_madc_suspend(struct device *pdev)
+{
+	int ret;
+	u8 reg_val;
+
+	ret = twl_i2c_read_u8(TWL_MODULE_MADC, &reg_val, TWL6030_MADC_CTRL);
+	if (!ret) {
+		reg_val &= ~(TWL6030_MADC_TEMP1_EN);
+		ret = twl_i2c_write_u8(TWL_MODULE_MADC, reg_val,
+					TWL6030_MADC_CTRL);
+	}
+
+	if (ret) {
+		dev_err(twl6030_madc->dev, "unable to disable madc temp1!\n");
+		gpadc_ctrl_reg = TWL6030_MADC_TEMP1_EN;
+	} else
+		gpadc_ctrl_reg = reg_val;
+
+	return 0;
+};
+
+static int twl6030_madc_resume(struct device *pdev)
+{
+	int ret;
+
+	if (!(gpadc_ctrl_reg & TWL6030_MADC_TEMP1_EN)) {
+		gpadc_ctrl_reg |= TWL6030_MADC_TEMP1_EN;
+		ret = twl_i2c_write_u8(TWL_MODULE_MADC, gpadc_ctrl_reg,
+					TWL6030_MADC_CTRL);
+		if (ret)
+			dev_err(twl6030_madc->dev,
+				"unable to enable madc temp1!\n");
+	}
+
+	return 0;
+};
+
+static const struct dev_pm_ops twl6030_madc_pm_ops = {
+	.suspend = twl6030_madc_suspend,
+	.resume = twl6030_madc_resume,
+};
+
+static struct platform_driver twl6030_madc_driver = {
+	.probe = twl6030_madc_probe,
+	.remove = __exit_p(twl6030_madc_remove),
+	.driver = {
+		   .name = "twl6030_madc",
+		   .owner = THIS_MODULE,
+		   .pm = &twl6030_madc_pm_ops,
+		   },
+};
+
+static int __init twl6030_madc_init(void)
+{
+	return platform_driver_register(&twl6030_madc_driver);
+}
+
+module_init(twl6030_madc_init);
+
+static void __exit twl6030_madc_exit(void)
+{
+	platform_driver_unregister(&twl6030_madc_driver);
+}
+
+module_exit(twl6030_madc_exit);
+
+MODULE_DESCRIPTION("TWL6030 ADC driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("J Keerthy");
+MODULE_ALIAS("platform:twl6030_madc");
diff --git a/include/linux/i2c/twl6030-madc.h b/include/linux/i2c/twl6030-madc.h
new file mode 100644
index 0000000..81b9464
--- /dev/null
+++ b/include/linux/i2c/twl6030-madc.h
@@ -0,0 +1,86 @@
+/*
+ * twl6030_madc.h - Header for TWL6030 MADC
+ *
+ * Copyright (C) 2011 Samsung Telecommunications of America
+ *
+ * Based on twl4030-madc.h
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ * J Keerthy <j-keerthy@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef _TWL6030_MADC_H
+#define _TWL6030_MADC_H
+
+#define TWL6030_MADC_MAX_CHANNELS 17
+/*
+ * twl6030 madc occupies the same offset in the twl6030 map that
+ * twl4030 madc does in the twl4030 map.
+ * likewise the charger
+ */
+#define TWL6030_MODULE_MADC          TWL4030_MODULE_MADC
+#define TWL6030_MODULE_MAIN_CHARGE   TWL4030_MODULE_MAIN_CHARGE
+
+#define TWL6030_MADC_CTRL		0x00
+#define    TWL6030_MADC_TEMP1_EN        (1 << 0)
+#define    TWL6030_MADC_TEMP2_EN        (1 << 1)
+#define    TWL6030_MADC_SCALER_EN_CH2	(1 << 2)
+#define    TWL6030_MADC_VBAT_SCALER_DIV	(1 << 3)
+#define    TWL6030_MADC_SCALER_EN_CH11	(1 << 4)
+#define    TWL6030_MADC_TMP1_EN_MONITOR	(1 << 5)
+#define    TWL6030_MADC_TMP2_EN_MONITOR	(1 << 6)
+#define    TWL6030_MADC_ISOURCE_EN	(1 << 7)
+
+#define TWL6030_MADC_RTSELECT_LSB	0x02
+#define    TWL6030_MADC_ADCIN0	(1 << 0)
+#define    TWL6030_MADC_ADCIN1	(1 << 1)
+#define    TWL6030_MADC_ADCIN2	(1 << 2)
+#define    TWL6030_MADC_ADCIN3	(1 << 3)
+#define    TWL6030_MADC_ADCIN4	(1 << 4)
+#define    TWL6030_MADC_ADCIN5	(1 << 5)
+#define    TWL6030_MADC_ADCIN6	(1 << 6)
+#define    TWL6030_MADC_ADCIN7	(1 << 7)
+
+#define TWL6030_MADC_RTSELECT_ISB	0x03
+#define    TWL6030_MADC_ADCIN8		(1 << 0)
+#define    TWL6030_MADC_ADCIN9		(1 << 1)
+#define    TWL6030_MADC_ADCIN10		(1 << 2)
+#define    TWL6030_MADC_ADCIN11		(1 << 3)
+#define    TWL6030_MADC_ADCIN12		(1 << 4)
+#define    TWL6030_MADC_ADCIN13		(1 << 5)
+#define    TWL6030_MADC_ADCIN14		(1 << 6)
+#define    TWL6030_MADC_ADCIN15		(1 << 7)
+
+#define TWL6030_MADC_RTSELECT_MSB	0x04
+#define    TWL6030_MADC_ADCIN16		(1 << 0)
+
+#define TWL6030_MADC_CTRL_P1		0x05
+#define    TWL6030_MADC_BUSY		(1 << 0)
+#define    TWL6030_MADC_EOCP1		(1 << 1)
+#define    TWL6030_MADC_EOCRT		(1 << 2)
+#define    TWL6030_MADC_SP1		(1 << 3)
+
+#define TWL6030_MADC_CTRL_P2		0x06
+#define    TWL6030_MADC_BUSYB		(1 << 0)
+#define    TWL6030_MADC_EOCP2		(1 << 1)
+#define    TWL6030_MADC_SP2		(1 << 2)
+
+#define TWL6030_MADC_RTCH0_LSB		0x07
+#define TWL6030_MADC_GPCH0_LSB		0x29
+
+int twl6030_get_madc_conversion(int channel_no);
+#endif
-- 
1.9.1

